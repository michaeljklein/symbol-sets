-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Type-level sets of Symbols
--   
--   Please see the README on GitHub at
--   <a>https://github.com/michaeljklein/symbol-sets#readme</a>
@package symbol-sets
@version 0.1.0.0


-- | Type-level <a>Set</a>s of <a>Symbol</a>s.
--   
--   While it's possible to use this module without
--   <tt>TypeApplications</tt>, it is recommended.
module Data.Set.Symbol

-- | Type-level sets:
--   
--   <pre>
--   λ&gt; set :: Set '["x", "y", "z"]
--   Set ["x","y","z"]
--   
--   λ&gt; set :: Set '["x", "z", "y"]
--   <a>interactive</a>:142:1: error:
--       • Couldn't match type ‘'GT’ with ‘'LT’ arising from a use of ‘set’
--       • In the expression: set :: Set '["x", "z", "y"]
--         In an equation for ‘it’: it = set :: Set '["x", "z", "y"]
--   </pre>
--   
--   Or with <tt>TypeApplications</tt> (much more concise):
--   
--   <pre>
--   λ&gt; :t set @["x", "y", "z"]
--   set @["x", "y", "z"] :: Set '["x", "y", "z"]
--   </pre>
newtype Set (a :: [Symbol])
Set :: Dict (IsSet a) -> Set
[setDict] :: Set -> Dict (IsSet a)

-- | This is an injective type-family that asserts that a list of
--   <a>Symbol</a>s represent a valid <a>Set</a>.

-- | Helper for <a>IsSet</a>, assuming a non-empty set by requiring an
--   additional parameter.

-- | The class of lists of symbols that can be reflected from a <a>Set</a>
class ReifySet (a :: [Symbol])
reflectSet :: ReifySet a => Set a -> [String]

-- | The empty <a>Set</a> is a <a>Set</a>
emptyIsSet :: Set '[]

-- | Insert a new <a>KnownSymbol</a>, that's known to be the minimum of the
--   <a>Set</a>
insertMinIsSet :: (KnownSymbol x, IsSet1 x xs) => proxy x -> Set xs -> Set (x : xs)

-- | We have a bijection between <a>Min1</a> and <a>Set1</a> when we have
--   <a>AllKnownSym1</a> fromMin1 :: (AllKnownSym1 x xs, Min1 x xs, Set xs)
--   :- Set1 x xs fromMin1 =
--   
--   Insert a new minimum <a>KnownSymbol</a> into a <a>Set1</a>
insertMinIsSet1 :: (KnownSymbol x, CmpSymbol x y ~  'LT) => proxy x -> Set1 y ys -> Set1 x (y : ys)

-- | The tail of a <a>Set</a> is a <a>Set</a>
tailSetIsSet :: Set (x : xs) -> Set xs

-- | The tail of a <a>Set1</a> is a <a>Set</a>
tailSet1IsSet :: Set1 x xs -> Set xs

-- | Non-empty <a>Set</a>
newtype Set1 (a :: Symbol) (as :: [Symbol])
Set1 :: Dict (IsSet (a : as)) -> Set1
[set1Dict] :: Set1 -> Dict (IsSet (a : as))

-- | If we know <tt>a ': as</tt> represents a <a>Set</a>, we can
--   instantiate a <tt><a>Set1</a> a as</tt>
set1 :: IsSet (a : as) => Set1 a as

-- | If <tt>x</tt> is a <a>KnownSymbol</a>, we can form a singleton
--   <a>Set1</a>
emptyKnownIsSet1 :: KnownSymbol x => Set1 x '[]

-- | A proof that all the <a>Symbol</a>s in the type-level list, as well as
--   the first provided <a>Symbol</a>, are all <a>KnownSymbol</a>s
newtype AllKnownSym1 (a :: Symbol) (as :: [Symbol])
AllKnownSym1 :: Dict (IsAllKnownSym1 a as) -> AllKnownSym1
[allKnownSym1Dict] :: AllKnownSym1 -> Dict (IsAllKnownSym1 a as)

-- | <a>Min1</a> encodes a non-empty <a>AllKnownSym1</a> <a>Set1</a>
newtype Min1 (a :: Symbol) (as :: [Symbol])
Min1 :: Dict (IsMin a as) -> Min1
[min1Dict] :: Min1 -> Dict (IsMin a as)

-- | Construct a <a>Set</a> using its type, e.g.
--   
--   <pre>
--   λ&gt; set :: Set '["x", "y", "z"]
--   Set ["x","y","z"]
--   </pre>
--   
--   Or with <tt>TypeApplications</tt> (much more concise):
--   
--   <pre>
--   λ&gt; set @["x", "y", "z"]
--   Set ["x", "y", "z"]
--   </pre>
set :: IsSet a => Set a

-- | A proof that the <a>tail</a> of a <a>Set</a> is a <a>Set</a>
tailIsSet :: IsSet (a : as) :- IsSet as

-- | A proof that the <a>head</a> of a <a>Set</a> is a <a>KnownSymbol</a>
headIsKnown :: IsSet (x : xs) :- KnownSymbol x

-- | Type-level <a>head</a>
headProxy :: Set (a : as) -> Proxy a

-- | Extract the elements after the <a>head</a> of a <a>Set</a>, which is
--   non-empty
tail :: Set (a : as) -> Set as

-- | Type-level <a>uncons</a>
unconsProxy :: Set (a : as) -> (Proxy a, Set as)

-- | Extract the first (least) element of a list, which is non-empty.
head :: Set (a : as) -> String

-- | Decompose a <a>Set</a> into its <a>head</a> and <a>tail</a>.
uncons :: Set (a : as) -> (String, Set as)

-- | Append two sets
--   
--   <pre>
--   λ&gt; set <tt> '["x", "y"] `<a>append</a>` set </tt> '["z"]
--   Set ["x","y","z"]
--   </pre>
append :: IsSet (a :<|> b) => Set a -> Set b -> Set (a :<|> b)

-- | Append two <a>Symbol</a> lists that represent <a>Set</a>s

-- | Insert a <a>Symbol</a> into a <a>Symbol</a> list of a <a>Set</a>

-- | a b result -&gt; c, a b result -&gt; bs, a c result -&gt; b

-- | Is a <a>Symbol</a> an <a>elem</a> of the given <a>Set</a>?
--   
--   <pre>
--   λ&gt; elem (Proxy <tt>"y") (set </tt> '["x","y","z"])
--   True
--   
--   λ&gt; elem (Proxy <tt>"y") (set </tt> '["x","z"])
--   False
--   </pre>
elem :: Reifies (ElemList s a) Bool => proxy (s :: Symbol) -> Set a -> Bool

-- | The type family behind <a>elem</a>

-- | <a>ElemList</a> assuming non-empty and with known <a>Ordering</a>

-- | Alias for <a>difference</a>
(\\) :: IsSet (Difference a b) => Set a -> Set b -> Set (Difference a b)

-- | Is this the empty <a>Set</a>?
null :: Reifies (a == '[]) Bool => Set a -> Bool

-- | Type-level implementation of <a>null</a>
nullProxy :: Set a -> Proxy (a == '[])

-- | The number of elements in the <a>Set</a>.
size :: KnownNat (Size a) => Set a -> Natural

-- | Type-level <a>size</a>
sizeProxy :: Set a -> Proxy (Size a)

-- | Type family encoding of <a>size</a>

-- | Is the element in the <a>Set</a>?
member :: Reifies (ElemList s a) Bool => proxy (s :: Symbol) -> Set a -> Bool

-- | Is the element not in the <a>Set</a>?
notMember :: Reifies (ElemList s a) Bool => proxy (s :: Symbol) -> Set a -> Bool

-- | Find largest element smaller than the given one.
--   
--   <pre>
--   lookupLT 3 (fromList [3, 5]) == Nothing
--   lookupLT 5 (fromList [3, 5]) == Just 3
--   </pre>
lookupLT :: Reifies (LookupLT a as) (Maybe String) => proxy (a :: Symbol) -> Set as -> Maybe String

-- | Type-level <a>lookupLT</a>
lookupLTProxy :: proxy (a :: Symbol) -> Set as -> Proxy (LookupLT a as :: Maybe Symbol)

-- | Type family encoding of <a>lookupLT</a>

-- | Type family encoding of the ternary operator (if <a>False</a> then
--   first argument else second)

-- | Type family encoding of:
--   
--   <pre>
--   x b -&gt;
--     if b
--       then Just x
--       else Nothing
--   </pre>

-- | Find smallest element greater than the given one.
--   
--   <pre>
--   lookupGT 4 (fromList [3, 5]) == Just 5
--   lookupGT 5 (fromList [3, 5]) == Nothing
--   </pre>
lookupGT :: Reifies (LookupGT a as) (Maybe String) => proxy (a :: Symbol) -> Set as -> Maybe String

-- | Type-level <a>lookupGT</a>
lookupGTProxy :: proxy (a :: Symbol) -> Set as -> Proxy (LookupGT a as :: Maybe Symbol)

-- | Type family encoding of <a>lookupGT</a>

-- | Find largest element smaller or equal to the given one.
--   
--   <pre>
--   lookupLE 2 (fromList [3, 5]) == Nothing
--   lookupLE 4 (fromList [3, 5]) == Just 3
--   lookupLE 5 (fromList [3, 5]) == Just 5
--   </pre>
lookupLE :: Reifies (LookupLE a as) (Maybe String) => proxy (a :: Symbol) -> Set as -> Maybe String

-- | Type-level <a>lookupLE</a>
lookupLEProxy :: proxy (a :: Symbol) -> Set as -> Proxy (LookupLE a as :: Maybe Symbol)

-- | Type family encoding of <a>lookupLE</a>

-- | Find smallest element greater or equal to the given one.
--   
--   <pre>
--   lookupGE 3 (fromList [3, 5]) == Just 3
--   lookupGE 4 (fromList [3, 5]) == Just 5
--   lookupGE 6 (fromList [3, 5]) == Nothing
--   </pre>
lookupGE :: Reifies (LookupGE a as) (Maybe String) => proxy (a :: Symbol) -> Set as -> Maybe String

-- | Type-level <a>lookupGE</a>
lookupGEProxy :: proxy (a :: Symbol) -> Set as -> Proxy (LookupGE a as :: Maybe Symbol)

-- | Type family encoding of <a>LookupGE</a>

-- | Is this a subset? <tt>(s1 <a>isSubsetOf</a> s2) tells whether
--   </tt>s1<tt> is a subset of </tt>s2@.
isSubsetOf :: Reifies (IsSubsetOf a b) Bool => Set a -> Set b -> Bool

-- | Type-level <a>isSubsetOf</a>
isSubsetOfProxy :: Set a -> Set b -> Proxy (IsSubsetOf a b :: Bool)

-- | Type family encoding of <a>isSubsetOf</a>

-- | Is this a proper subset? (ie. a subset but not equal).
isProperSubsetOf :: Reifies (IsSubsetOf a b && Not (a == b)) Bool => Set a -> Set b -> Bool

-- | Type-level <a>isProperSubsetOf</a>
isProperSubsetOfProxy :: Set a -> Set b -> Proxy (IsProperSubsetOf a b :: Bool)

-- | Type family encoding of <a>isProperSubsetOf</a>

-- | Check whether two <a>Set</a>s are disjoint (i.e. their intersection is
--   <a>empty</a>).
--   
--   <pre>
--   disjoint (fromList [2,4,6])   (fromList [1,3])     == True
--   disjoint (fromList [2,4,6,8]) (fromList [2,3,5,7]) == False
--   disjoint (fromList [1,2])     (fromList [1,2,3,4]) == False
--   disjoint (fromList [])        (fromList [])        == True
--   </pre>
disjoint :: Reifies (Intersection a b == '[]) Bool => Set a -> Set b -> Bool

-- | Type-level <a>disjoint</a>
disjointProxy :: Set a -> Set b -> Proxy (Disjoint a b :: Bool)

-- | Type family encoding of <a>disjoint</a>

-- | The empty <a>Set</a>.
empty :: Set '[]

-- | Construct a <a>Set</a> containing a single element
singleton :: KnownSymbol a => proxy (a :: Symbol) -> Set '[a]

-- | Insert an element in a set. If the set already contains an element
--   equal to the given value, it is replaced with the new value.
insert :: IsSet (a : as) => proxy (a :: Symbol) -> Set as -> Set (a : as)

-- | Delete an element from a set.
delete :: IsSet (Delete a as) => proxy (a :: Symbol) -> Set as -> Set (Delete a as)

-- | Type family encoding of <a>delete</a>

-- | We do:
--   
--   <pre>
--   powerset someSet = Set [concat subset | subset &lt;- toList (powerSet someSet)]
--   </pre>
powerSet :: IsSet (PowerSet a) => Set a -> Set (PowerSet a)

-- | Type family encoding of <a>powerSet</a>

-- | Prepend the given <a>Symbol</a> to all elements of the list (preserves
--   order)

-- | The union of two sets
union :: IsSet (a :<|> b) => Set a -> Set b -> Set (a :<|> b)

-- | Difference of two <a>Set</a>s.
difference :: IsSet (Difference a b) => Set a -> Set b -> Set (Difference a b)

-- | Type family encoding of <a>difference</a>

-- | The intersection of two <a>Set</a>s.
intersection :: IsSet (Intersection a b) => Set a -> Set b -> Set (Intersection a b)

-- | Type family encoding of <a>intersection</a>

-- | Calculate the Cartesian product of two <a>Set</a>s. Since there are no
--   tuples, the elements are appended instead of paired in the result.
--   
--   <pre>
--   cartesianProduct xs ys = fromList $ liftA2 (,) (toList xs) (toList ys)
--   </pre>
--   
--   Example:
--   
--   <pre>
--   cartesianProduct (fromList [1,2]) (fromList [a,b]) =
--     fromList [(1,a), (1,b), (2,a), (2,b)]
--   </pre>
cartesianProduct :: IsSet (CartesianProduct a b) => Set a -> Set b -> Set (CartesianProduct a b)

-- | Type family encoding of <a>cartesianProduct</a>

-- | Only retain elements less than the given one
filterLT :: IsSet (FilterLT a as) => proxy (a :: Symbol) -> Set as -> Set (FilterLT a as)

-- | Type family encoding of <a>filterLT</a>

-- | Only retain elements greater than the given one
filterGT :: IsSet (FilterGT a as) => proxy (a :: Symbol) -> Set as -> Set (FilterGT a as)

-- | Type family encoding of <a>filterGT</a>

-- | The expression (split x set) is a pair (set1,set2) where set1
--   comprises the elements of set less than x and set2 comprises the
--   elements of set greater than x
split :: (IsSet (FilterLT a as), IsSet (FilterGT a as)) => proxy (a :: Symbol) -> Set as -> (Set (FilterLT a as), Set (FilterGT a as))

-- | Performs a split but also returns whether the pivot element was found
--   in the original set.
splitMember :: (IsSet (FilterLT a as), Reifies (ElemList a as) Bool, IsSet (FilterGT a as)) => proxy (a :: Symbol) -> Set as -> (Set (FilterLT a as), Bool, Set (FilterGT a as))

-- | Lookup the index of an element, which is its zero-based index in the
--   sorted sequence of elements. The index is a number from 0 up to, but
--   not including, the size of the set.
--   
--   <pre>
--   isJust   (lookupIndex 2 (fromList [5,3])) == False
--   fromJust (lookupIndex 3 (fromList [5,3])) == 0
--   fromJust (lookupIndex 5 (fromList [5,3])) == 1
--   isJust   (lookupIndex 6 (fromList [5,3])) == False
--   </pre>
lookupIndex :: Reifies (LookupIndex a as) (Maybe Natural) => proxy (a :: Symbol) -> Set as -> Maybe Natural

-- | Type-level <a>lookupIndex</a>
lookupIndexProxy :: proxy (a :: Symbol) -> Set as -> Proxy (LookupIndex a as :: Maybe Nat)

-- | Type family encoding of <a>lookupIndex</a>

-- | Equivalent to <tt><a>fmap</a> (<a>+</a> 1)</tt>

-- | Return the index of an element, which is its zero-based index in the
--   sorted sequence of elements. The index is a number from 0 up to, but
--   not including, the size of the set.
--   
--   <pre>
--   findIndex 2 (fromList [5,3])    Error: element is not in the set
--   findIndex 3 (fromList [5,3]) == 0
--   findIndex 5 (fromList [5,3]) == 1
--   findIndex 6 (fromList [5,3])    Error: element is not in the set
--   </pre>
findIndex :: (KnownNat (FindIndex a as), ElemList a as ~  'True) => proxy (a :: Symbol) -> Set as -> Natural

-- | Type-level <a>findIndex</a>
findIndexProxy :: (KnownNat (FindIndex a as), ElemList a as ~  'True) => proxy (a :: Symbol) -> Set as -> Proxy (FindIndex a as)

-- | Type family encoding of <a>findIndex</a>

-- | Retrieve an element by its index, i.e. by its zero-based index in the
--   sorted sequence of elements. If the index is out of range (less than
--   zero, greater or equal to size of the set), error is called.
--   
--   <pre>
--   elemAt 0 (fromList [5,3]) == 3
--   elemAt 1 (fromList [5,3]) == 5
--   elemAt 2 (fromList [5,3])    Error: index out of range
--   </pre>
elemAt :: (i < Size a ~  'True, KnownSymbol (ElemAt i a)) => proxy (i :: Nat) -> Set a -> String

-- | Type-level <a>elemAt</a>
elemAtProxy :: (i < Size a ~  'True) => proxy (i :: Nat) -> Set a -> Proxy (ElemAt i a :: Symbol)

-- | Type family representing less than

-- | Type level <a>not</a>

-- | Type level <tt>(<a>/=</a>)</tt>

-- | Tyoe level <tt>(<a>&amp;&amp;</a>)</tt>

-- | Type family encoding of <a>elemAt</a>

-- | Delete the element at index, i.e. by its zero-based index in the
--   sorted sequence of elements. If the index is out of range (less than
--   zero, greater or equal to size of the set), error is called.
--   
--   <pre>
--   deleteAt 0    (fromList [5,3]) == singleton 5
--   deleteAt 1    (fromList [5,3]) == singleton 3
--   deleteAt 2    (fromList [5,3])    Error: index out of range
--   deleteAt (-1) (fromList [5,3])    Error: index out of range
--   </pre>
deleteAt :: IsSet (DeleteAt i a) => proxy (i :: Nat) -> Set a -> Set (DeleteAt i a)

-- | Type family encoding of <a>deleteAt</a>

-- | Take a given number of elements in order, beginning with the smallest
--   ones.
take :: IsSet (Take i a) => proxy (i :: Nat) -> Set a -> Set (Take i a)

-- | Type family encoding of <a>take</a>

-- | Drop a given number of elements in order, beginning with the smallest
--   ones.
drop :: IsSet (Drop i a) => proxt (i :: Nat) -> Set a -> Set (Drop i a)

-- | Type family encoding of <a>drop</a>

-- | Split a set at a particular index.
--   
--   <pre>
--   splitAt n xs = (take n xs, drop n xs)
--   </pre>
splitAt :: (IsSet (Take i a), IsSet (Drop i a)) => proxy (i :: Nat) -> Set a -> (Set (Take i a), Set (Drop i a))

-- | The minimal element of a set.
lookupMin :: ReifySet a => Set a -> Maybe String

-- | The maximal element of a set.
lookupMax :: ReifySet a => Set a -> Maybe String

-- | The minimal element of a set.
findMin :: ReifySet (a : as) => Set (a : as) -> String

-- | The maximal element of a set.
findMax :: ReifySet (a : as) => Set (a : as) -> String

-- | Delete the minimal element. Returns an empty set if the set is empty.
deleteMin :: Set (a : as) -> Set as

-- | Delete the maximal element. Returns an empty set if the set is empty.
deleteMax :: IsSet (DeleteMax a) => Set a -> Set (DeleteMax a)

-- | Type family encoding of <a>deleteMax</a>

-- | Delete and find the minimal element. deleteFindMin set = (findMin set,
--   deleteMin set)
deleteFindMin :: Set (a : as) -> (String, Set as)

-- | Delete and find the maximal element. deleteFindMax set = (findMax set,
--   deleteMax set)
deleteFindMax :: (IsSet (DeleteMax (a : as)), ReifySet (a : as)) => Set (a : as) -> (String, Set (DeleteMax (a : as)))

-- | Retrieves the maximal key of the set, and the set stripped of that
--   element, or Nothing if passed an empty set.
maxView :: (IsSet (DeleteMax a), ReifySet a) => Set a -> Maybe (String, Set (DeleteMax a))

-- | Retrieves the minimal key of the set, and the set stripped of that
--   element, or Nothing if passed an empty set.
minView :: ReifySet (a : as) => Set (a : as) -> Maybe (String, Set as)

-- | Lift a function returning a type that we can <a>reflect</a>
liftReflect2 :: Reifies s c => (a -> b -> proxy s) -> a -> b -> c
instance Control.DeepSeq.NFData (Data.Set.Symbol.Min1 a as)
instance GHC.Classes.Ord (Data.Set.Symbol.Min1 a as)
instance (Data.Set.Symbol.IsMin a as, GHC.TypeLits.KnownSymbol a, Data.Typeable.Internal.Typeable as, Data.Typeable.Internal.Typeable (Data.Set.Symbol.IsMin a as)) => Data.Data.Data (Data.Set.Symbol.Min1 a as)
instance GHC.Classes.Eq (Data.Set.Symbol.Min1 a as)
instance Control.DeepSeq.NFData (Data.Set.Symbol.AllKnownSym1 a as)
instance GHC.Classes.Ord (Data.Set.Symbol.AllKnownSym1 a as)
instance (Data.Set.Symbol.IsAllKnownSym as, GHC.TypeLits.KnownSymbol a, Data.Typeable.Internal.Typeable as, Data.Typeable.Internal.Typeable (Data.Set.Symbol.IsAllKnownSym as)) => Data.Data.Data (Data.Set.Symbol.AllKnownSym1 a as)
instance GHC.Classes.Eq (Data.Set.Symbol.AllKnownSym1 a as)
instance Control.DeepSeq.NFData (Data.Set.Symbol.Set1 a as)
instance GHC.Classes.Ord (Data.Set.Symbol.Set1 a as)
instance (Data.Set.Symbol.IsSet1 a as, Data.Set.Symbol.IsSet as, GHC.TypeLits.KnownSymbol a, Data.Typeable.Internal.Typeable as, Data.Typeable.Internal.Typeable (Data.Set.Symbol.IsSet1 a as), Data.Typeable.Internal.Typeable (Data.Set.Symbol.IsSet as)) => Data.Data.Data (Data.Set.Symbol.Set1 a as)
instance GHC.Classes.Eq (Data.Set.Symbol.Set1 a as)
instance Control.DeepSeq.NFData (Data.Set.Symbol.Set a)
instance GHC.Classes.Ord (Data.Set.Symbol.Set a)
instance (Data.Set.Symbol.IsSet a, Data.Typeable.Internal.Typeable a, Data.Typeable.Internal.Typeable (Data.Set.Symbol.IsSet a)) => Data.Data.Data (Data.Set.Symbol.Set a)
instance GHC.Classes.Eq (Data.Set.Symbol.Set a)
instance Data.Set.Symbol.ReifySet a => GHC.Show.Show (Data.Set.Symbol.Set a)
instance (Data.Set.Symbol.ReifySet a, Data.Set.Symbol.IsSet a) => GHC.Read.Read (Data.Set.Symbol.Set a)
instance Data.Set.Symbol.ReifySet '[]
instance Data.Set.Symbol.ReifySet as => Data.Set.Symbol.ReifySet (a : as)
instance (Data.Set.Symbol.ReifySet a, Data.Set.Symbol.IsSet a) => GHC.Exts.IsList (Data.Set.Symbol.Set a)
instance Data.Set.Symbol.IsSet s => GHC.Base.Semigroup (Data.Set.Symbol.Set s)
instance Data.Set.Symbol.IsSet s => GHC.Base.Monoid (Data.Set.Symbol.Set s)
instance forall k a (s :: k). Data.Reflection.Reifies s a => Data.Reflection.Reifies '('Data.Proxy.Proxy, 'GHC.Base.Nothing) (GHC.Base.Maybe a)
instance forall k a (s :: k). Data.Reflection.Reifies s a => Data.Reflection.Reifies '('Data.Proxy.Proxy, 'GHC.Base.Just s) (GHC.Base.Maybe a)
instance Data.Reflection.Reifies 'GHC.Types.True GHC.Types.Bool
instance Data.Reflection.Reifies 'GHC.Types.False GHC.Types.Bool

module Data.Type.Set

-- | The constraint that all of the elements of the given list satisfy the
--   given constraint.

-- | A newtype-wrapped dictionary of the constraint <a>AllElemsC</a>
newtype AllElems (c :: k -> Constraint) (as :: [k])
AllElems :: Dict (AllElemsC c as) -> AllElems
[allElemsDict] :: AllElems -> Dict (AllElemsC c as)

-- | Construct an instance of <a>AllElems</a>
allElems :: AllElemsC c as => AllElems c as

-- | <a>AllElems</a> is vacuously true for any <a>Constraint</a> on the
--   empty list
emptyAllElems :: forall (c :: k -> Constraint). AllElems c '[]

-- | If <tt><a>AllElems</a> c (a ': as)`</tt> then <tt>c a</tt>
headAllElems :: AllElems c (a : as) -> Dict (c a)

-- | If <tt><a>AllElems</a> c (a ': as)`</tt> then <tt><a>AllElems</a> c
--   as</tt>
tailAllElems :: AllElems c (a : as) -> AllElems c as

-- | <a>headAllElems</a> and <a>tailAllElems</a>
unconsAllElems :: AllElems c (a : as) -> (Dict (c a), AllElems c as)

-- | Concatenate an instance of a <a>Constraint</a> onto the front of an
--   <a>AllElems</a>
consAllElems :: Dict (c a) -> AllElems c as -> AllElems c (a : as)

-- | Type-class of types that reify to a list of a given type.
--   
--   If I remember correctly, the instance <tt><a>ReifiesList</a> [] a</tt>
--   prevents a functional dependency from <tt>as</tt> to <tt>a</tt>.
class ReifiesList (as :: [k]) (a :: *)
reflectList :: ReifiesList as a => proxy as -> [a]

-- | Type class of types that may be compared with another of the same kind
class Compare (a :: k) where {
    type family Cmp (a :: k) (b :: k) :: Ordering;
}

-- | The <a>Constraint</a> that a type-level list is strictly increasing

-- | The tail of <a>Inc</a>

-- | <a>undefined</a>
inductMap :: (c '[] :- d '[]) -> (forall (x :: k) (xs :: [k]). c (x : xs) :- d (x : xs)) -> c ys :- d ys

-- | <a>undefined</a>
induceMap :: forall (k :: *) (c :: [k] -> Constraint) (ys :: [k]). Dict (c '[]) -> (forall (x :: k) (xs :: [k]). Dict (c (x : xs))) -> Dict (c (ys :: [k]))

-- | The tail of <a>Inc</a> entails <a>Inc</a> of <tt>[]</tt>
tailIncEmpty :: forall a. Inc1 a '[] :- Inc '[]

-- | The tail of I
tailIncCons :: forall (a :: k) (b :: k) (bs :: [k]). Inc1 a (b : bs) :- Inc (b : bs)

-- | In theory, we could induce on <a>tailIncEmpty</a> and
--   <a>tailIncCons</a>...
tailInc1 :: Dict (Inc1 a as) -> Dict (Inc as)

-- | Convert <a>Inc</a> of a non-empty type-level list to <a>Inc1</a>
incToInc1 :: Dict (Inc (a : as)) -> Dict (Inc1 a as)

-- | Singleton <a>Set</a>s, represented on the type-level by type-level
--   strictly increasing lists
newtype Set (as :: [k])
Set :: Dict (Inc as) -> Set
[setDict] :: Set -> Dict (Inc as)

-- | If <tt>as</tt> is strictly increasing, then it represents a valid
--   <a>Set</a> of values
set :: Inc as => Set as

-- | Get the first value in a non-empty <a>Set</a>
head :: Set (a : as) -> Proxy a

-- | Get the tail of a non-empty <a>Set</a>
tail :: Set (a : as) -> Set as

-- | The <a>Constraint</a> that an element of a type-level list is its
--   minimum.

-- | The singleton representing a proof that an element of a type-level
--   list is its minimum.
newtype MinOf (a :: k) (as :: [k])
MinOf :: Dict (MinOfC a as) -> MinOf
[minOfDict] :: MinOf -> Dict (MinOfC a as)

-- | <a>MinOf</a> may be instantiated whenever <a>MinOfC</a> holds
minOf :: MinOfC a as => MinOf a as

-- | See <a>MinOfC</a>

-- | See <a>MinOf</a>
newtype MaxOf (a :: k) (as :: [k])
MaxOf :: Dict (MaxOfC a as) -> MaxOf
[maxOfDict] :: MaxOf -> Dict (MaxOfC a as)

-- | See <a>minOf</a>
maxOf :: MaxOfC a as => MaxOf a as

-- | Postpend an element to a type-level list

-- | (Incomplete) Insert an element into a strictly increasing type-level
--   list

-- | (Incomplete) Delete an element from a type-level list
instance forall k (a :: k) (as :: [k]). Control.DeepSeq.NFData (Data.Type.Set.MaxOf a as)
instance forall k (a :: k) (as :: [k]). GHC.Classes.Ord (Data.Type.Set.MaxOf a as)
instance forall k (a :: k) (as :: [k]). GHC.Classes.Eq (Data.Type.Set.MaxOf a as)
instance forall k (a :: k) (as :: [k]). Control.DeepSeq.NFData (Data.Type.Set.MinOf a as)
instance forall k (a :: k) (as :: [k]). GHC.Classes.Ord (Data.Type.Set.MinOf a as)
instance forall k (a :: k) (as :: [k]). GHC.Classes.Eq (Data.Type.Set.MinOf a as)
instance forall k (as :: [k]). Control.DeepSeq.NFData (Data.Type.Set.Set as)
instance forall k (as :: [k]). GHC.Classes.Ord (Data.Type.Set.Set as)
instance forall k (as :: [k]). GHC.Classes.Eq (Data.Type.Set.Set as)
instance forall k (c :: k -> GHC.Types.Constraint) (as :: [k]). Control.DeepSeq.NFData (Data.Type.Set.AllElems c as)
instance forall k (c :: k -> GHC.Types.Constraint) (as :: [k]). GHC.Classes.Ord (Data.Type.Set.AllElems c as)
instance forall k (c :: k -> GHC.Types.Constraint) (as :: [k]). GHC.Classes.Eq (Data.Type.Set.AllElems c as)
instance Data.Type.Set.ReifiesList '[] a
instance forall k (t :: k) a (as :: [k]). (Data.Reflection.Reifies t a, Data.Type.Set.ReifiesList as a) => Data.Type.Set.ReifiesList (t : as) a
